{"version":3,"sources":["../src/fragmentMatcher.ts","../src/depTrackingCache.ts","../src/readFromStore.ts","../src/objectCache.ts","../src/writeToStore.ts","../src/inMemoryCache.ts"],"names":["defaultNormalizedCacheFactory","hasOwn"],"mappings":"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","sourcesContent":["import { isTest, IdValue } from 'apollo-utilities';\nimport { invariant } from 'ts-invariant';\n\nimport {\n  ReadStoreContext,\n  FragmentMatcherInterface,\n  PossibleTypesMap,\n  IntrospectionResultData,\n} from './types';\n\nlet haveWarned = false;\n\nfunction shouldWarn() {\n  const answer = !haveWarned;\n  /* istanbul ignore if */\n  if (!isTest()) {\n    haveWarned = true;\n  }\n  return answer;\n}\n\n/**\n * This fragment matcher is very basic and unable to match union or interface type conditions\n */\nexport class HeuristicFragmentMatcher implements FragmentMatcherInterface {\n  constructor() {\n    // do nothing\n  }\n\n  public ensureReady() {\n    return Promise.resolve();\n  }\n\n  public canBypassInit() {\n    return true; // we don't need to initialize this fragment matcher.\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ): boolean | 'heuristic' {\n    const obj = context.store.get(idValue.id);\n    const isRootQuery = idValue.id === 'ROOT_QUERY';\n\n    if (!obj) {\n      // https://github.com/apollographql/apollo-client/pull/3507\n      return isRootQuery;\n    }\n\n    const { __typename = isRootQuery && 'Query' } = obj;\n\n    if (!__typename) {\n      if (shouldWarn()) {\n        invariant.warn(`You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.`);\n        invariant.warn(\n          'Could not find __typename on Fragment ',\n          typeCondition,\n          obj,\n        );\n        invariant.warn(\n          `DEPRECATION WARNING: using fragments without __typename is unsupported behavior ` +\n            `and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.`,\n        );\n      }\n\n      return 'heuristic';\n    }\n\n    if (__typename === typeCondition) {\n      return true;\n    }\n\n    // At this point we don't know if this fragment should match or not. It's\n    // either:\n    //\n    // 1. (GOOD) A fragment on a matching interface or union.\n    // 2. (BAD) A fragment on a non-matching concrete type or interface or union.\n    //\n    // If it's 2, we don't want it to match. If it's 1, we want it to match. We\n    // can't tell the difference, so we warn the user, but still try to match\n    // it (for backwards compatibility reasons). This unfortunately means that\n    // using the `HeuristicFragmentMatcher` with unions and interfaces is\n    // very unreliable. This will be addressed in a future major version of\n    // Apollo Client, but for now the recommendation is to use the\n    // `IntrospectionFragmentMatcher` when working with unions/interfaces.\n\n    if (shouldWarn()) {\n      invariant.error(\n        'You are using the simple (heuristic) fragment matcher, but your ' +\n          'queries contain union or interface types. Apollo Client will not be ' +\n          'able to accurately map fragments. To make this error go away, use ' +\n          'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n          'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher',\n      );\n    }\n\n    return 'heuristic';\n  }\n}\n\nexport class IntrospectionFragmentMatcher implements FragmentMatcherInterface {\n  private isReady: boolean;\n  private possibleTypesMap: PossibleTypesMap;\n\n  constructor(options?: {\n    introspectionQueryResultData?: IntrospectionResultData;\n  }) {\n    if (options && options.introspectionQueryResultData) {\n      this.possibleTypesMap = this.parseIntrospectionResult(\n        options.introspectionQueryResultData,\n      );\n      this.isReady = true;\n    } else {\n      this.isReady = false;\n    }\n\n    this.match = this.match.bind(this);\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ) {\n    invariant(\n      this.isReady,\n      'FragmentMatcher.match() was called before FragmentMatcher.init()',\n    );\n\n    const obj = context.store.get(idValue.id);\n    const isRootQuery = idValue.id === 'ROOT_QUERY';\n\n    if (!obj) {\n      // https://github.com/apollographql/apollo-client/pull/4620\n      return isRootQuery;\n    }\n\n    const { __typename = isRootQuery && 'Query' } = obj;\n\n    invariant(\n      __typename,\n      `Cannot match fragment because __typename property is missing: ${JSON.stringify(\n        obj,\n      )}`,\n    );\n\n    if (__typename === typeCondition) {\n      return true;\n    }\n\n    const implementingTypes = this.possibleTypesMap[typeCondition];\n    if (\n      __typename &&\n      implementingTypes &&\n      implementingTypes.indexOf(__typename) > -1\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private parseIntrospectionResult(\n    introspectionResultData: IntrospectionResultData,\n  ): PossibleTypesMap {\n    const typeMap: PossibleTypesMap = {};\n    introspectionResultData.__schema.types.forEach(type => {\n      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n        typeMap[type.name] = type.possibleTypes.map(\n          implementingType => implementingType.name,\n        );\n      }\n    });\n    return typeMap;\n  }\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\nimport { wrap, OptimisticWrapperFunction } from 'optimism';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class DepTrackingCache implements NormalizedCache {\n  // Wrapper function produced by the optimism library, used to depend on\n  // dataId strings, for easy invalidation of specific IDs.\n  private depend: OptimisticWrapperFunction<[string], StoreObject | undefined>;\n\n  constructor(private data: NormalizedCacheObject = Object.create(null)) {\n    this.depend = wrap((dataId: string) => this.data[dataId], {\n      disposable: true,\n      makeCacheKey(dataId: string) {\n        return dataId;\n      },\n    });\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return this.data;\n  }\n\n  public get(dataId: string): StoreObject {\n    this.depend(dataId);\n    return this.data[dataId]!;\n  }\n\n  public set(dataId: string, value?: StoreObject) {\n    const oldValue = this.data[dataId];\n    if (value !== oldValue) {\n      this.data[dataId] = value;\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public delete(dataId: string): void {\n    if (hasOwn.call(this.data, dataId)) {\n      delete this.data[dataId];\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    if (newData) {\n      Object.keys(newData).forEach(dataId => {\n        this.set(dataId, newData[dataId]);\n      });\n      Object.keys(this.data).forEach(dataId => {\n        if (!hasOwn.call(newData, dataId)) {\n          this.delete(dataId);\n        }\n      });\n    } else {\n      Object.keys(this.data).forEach(dataId => {\n        this.delete(dataId);\n      });\n    }\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new DepTrackingCache(seed);\n}\n","import {\n  argumentsObjectFromField,\n  assign,\n  canUseWeakMap,\n  createFragmentMap,\n  DirectiveInfo,\n  FragmentMap,\n  getDefaultValues,\n  getDirectiveInfoFromField,\n  getFragmentDefinitions,\n  getMainDefinition,\n  getQueryDefinition,\n  getStoreKeyName,\n  IdValue,\n  isEqual,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isJsonValue,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  resultKeyNameFromField,\n  shouldInclude,\n  StoreValue,\n  toIdValue,\n} from 'apollo-utilities';\n\nimport { Cache } from 'apollo-cache';\n\nimport {\n  ReadStoreContext,\n  DiffQueryAgainstStoreOptions,\n  ReadQueryOptions,\n  StoreObject,\n} from './types';\n\nimport {\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n  SelectionSetNode,\n} from 'graphql';\n\nimport { wrap, KeyTrie } from 'optimism';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: ReadStoreContext,\n) => boolean | 'heuristic';\n\ntype ExecContext = {\n  query: DocumentNode;\n  fragmentMap: FragmentMap;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n};\n\ntype ExecInfo = {\n  resultKey: string;\n  directives: DirectiveInfo;\n};\n\nexport type ExecResultMissingField = {\n  object: StoreObject;\n  fieldName: string;\n  tolerable: boolean;\n};\n\nexport type ExecResult<R = any> = {\n  result: R;\n  // Empty array if no missing fields encountered while computing result.\n  missing?: ExecResultMissingField[];\n};\n\ntype ExecStoreQueryOptions = {\n  query: DocumentNode;\n  rootValue: IdValue;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  // Default matcher always matches all fragments\n  fragmentMatcher?: FragmentMatcher;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  rootValue: any;\n  execContext: ExecContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: any[];\n  execContext: ExecContext;\n};\n\nexport interface StoreReaderConfig {\n  cacheKeyRoot?: KeyTrie<object>;\n  freezeResults?: boolean;\n}\n\nexport class StoreReader {\n  private freezeResults: boolean;\n\n  constructor({\n    cacheKeyRoot = new KeyTrie<object>(canUseWeakMap),\n    freezeResults = false,\n  }: StoreReaderConfig = {}) {\n    const {\n      executeStoreQuery,\n      executeSelectionSet,\n      executeSubSelectedArray,\n    } = this;\n\n    this.freezeResults = freezeResults;\n\n    this.executeStoreQuery = wrap((options: ExecStoreQueryOptions) => {\n      return executeStoreQuery.call(this, options);\n    }, {\n      makeCacheKey({\n        query,\n        rootValue,\n        contextValue,\n        variableValues,\n        fragmentMatcher,\n      }: ExecStoreQueryOptions) {\n        // The result of executeStoreQuery can be safely cached only if the\n        // underlying store is capable of tracking dependencies and invalidating\n        // the cache when relevant data have changed.\n        if (contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            contextValue.store,\n            query,\n            fragmentMatcher,\n            JSON.stringify(variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSelectionSet = wrap((options: ExecSelectionSetOptions) => {\n      return executeSelectionSet.call(this, options);\n    }, {\n      makeCacheKey({\n        selectionSet,\n        rootValue,\n        execContext,\n      }: ExecSelectionSetOptions) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            execContext.contextValue.store,\n            selectionSet,\n            execContext.fragmentMatcher,\n            JSON.stringify(execContext.variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSubSelectedArray = wrap((options: ExecSubSelectedArrayOptions) => {\n      return executeSubSelectedArray.call(this, options);\n    }, {\n      makeCacheKey({ field, array, execContext }) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            execContext.contextValue.store,\n            field,\n            array,\n            JSON.stringify(execContext.variableValues),\n          );\n        }\n      }\n    });\n  }\n\n  /**\n   * Resolves the result of a query solely from the store (i.e. never hits the server).\n   *\n   * @param {Store} store The {@link NormalizedCache} used by Apollo for the `data` portion of the\n   * store.\n   *\n   * @param {DocumentNode} query The query document to resolve from the data available in the store.\n   *\n   * @param {Object} [variables] A map from the name of a variable to its value. These variables can\n   * be referenced by the query document.\n   *\n   * @param {any} previousResult The previous result returned by this function for the same query.\n   * If nothing in the store changed since that previous result then values from the previous result\n   * will be returned to preserve referential equality.\n   */\n  public readQueryFromStore<QueryType>(\n    options: ReadQueryOptions,\n  ): QueryType | undefined {\n    return this.diffQueryAgainstStore<QueryType>({\n      ...options,\n      returnPartialData: false,\n    }).result;\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   * @param  {DocumentNode} query A parsed GraphQL query document\n   * @param  {Store} store The Apollo Client store object\n   * @param  {any} previousResult The previous result returned by this function for the same query\n   * @return {result: Object, complete: [boolean]}\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    variables,\n    previousResult,\n    returnPartialData = true,\n    rootId = 'ROOT_QUERY',\n    fragmentMatcherFunction,\n    config,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    // Throw the right validation error by trying to find a query in the document\n    const queryDefinition = getQueryDefinition(query);\n\n    variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n    const context: ReadStoreContext = {\n      // Global settings\n      store,\n      dataIdFromObject: config && config.dataIdFromObject,\n      cacheRedirects: (config && config.cacheRedirects) || {},\n    };\n\n    const execResult = this.executeStoreQuery({\n      query,\n      rootValue: {\n        type: 'id',\n        id: rootId,\n        generated: true,\n        typename: 'Query',\n      },\n      contextValue: context,\n      variableValues: variables,\n      fragmentMatcher: fragmentMatcherFunction,\n    });\n\n    const hasMissingFields =\n      execResult.missing && execResult.missing.length > 0;\n\n    if (hasMissingFields && ! returnPartialData) {\n      execResult.missing!.forEach(info => {\n        if (info.tolerable) return;\n        throw new InvariantError(\n          `Can't find field ${info.fieldName} on object ${JSON.stringify(\n            info.object,\n            null,\n            2,\n          )}.`,\n        );\n      });\n    }\n\n    if (previousResult) {\n      if (isEqual(previousResult, execResult.result)) {\n        execResult.result = previousResult;\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !hasMissingFields,\n    };\n  }\n\n  /**\n   * Based on graphql function from graphql-js:\n   *\n   * graphql(\n   *   schema: GraphQLSchema,\n   *   requestString: string,\n   *   rootValue?: ?any,\n   *   contextValue?: ?any,\n   *   variableValues?: ?{[key: string]: any},\n   *   operationName?: ?string\n   * ): Promise<GraphQLResult>\n   *\n   * The default export as of graphql-anywhere is sync as of 4.0,\n   * but below is an exported alternative that is async.\n   * In the 5.0 version, this will be the only export again\n   * and it will be async\n   *\n   */\n  private executeStoreQuery({\n    query,\n    rootValue,\n    contextValue,\n    variableValues,\n    // Default matcher always matches all fragments\n    fragmentMatcher = defaultFragmentMatcher,\n  }: ExecStoreQueryOptions): ExecResult {\n    const mainDefinition = getMainDefinition(query);\n    const fragments = getFragmentDefinitions(query);\n    const fragmentMap = createFragmentMap(fragments);\n    const execContext: ExecContext = {\n      query,\n      fragmentMap,\n      contextValue,\n      variableValues,\n      fragmentMatcher,\n    };\n\n    return this.executeSelectionSet({\n      selectionSet: mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    });\n  }\n\n  private executeSelectionSet({\n    selectionSet,\n    rootValue,\n    execContext,\n  }: ExecSelectionSetOptions): ExecResult {\n    const { fragmentMap, contextValue, variableValues: variables } = execContext;\n    const finalResult: ExecResult = { result: null };\n\n    const objectsToMerge: { [key: string]: any }[] = [];\n\n    const object: StoreObject = contextValue.store.get(rootValue.id);\n\n    const typename =\n      (object && object.__typename) ||\n      (rootValue.id === 'ROOT_QUERY' && 'Query') ||\n      void 0;\n\n    function handleMissing<T>(result: ExecResult<T>): T {\n      if (result.missing) {\n        finalResult.missing = finalResult.missing || [];\n        finalResult.missing.push(...result.missing);\n      }\n      return result.result;\n    }\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely\n        return;\n      }\n\n      if (isField(selection)) {\n        const fieldResult = handleMissing(\n          this.executeField(object, typename, selection, execContext),\n        );\n\n        if (typeof fieldResult !== 'undefined') {\n          objectsToMerge.push({\n            [resultKeyNameFromField(selection)]: fieldResult,\n          });\n        }\n\n      } else {\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // This is a named fragment\n          fragment = fragmentMap[selection.name.value];\n\n          if (!fragment) {\n            throw new InvariantError(`No fragment named ${selection.name.value}`);\n          }\n        }\n\n        const typeCondition =\n          fragment.typeCondition && fragment.typeCondition.name.value;\n\n        const match =\n          !typeCondition ||\n          execContext.fragmentMatcher(rootValue, typeCondition, contextValue);\n\n        if (match) {\n          let fragmentExecResult = this.executeSelectionSet({\n            selectionSet: fragment.selectionSet,\n            rootValue,\n            execContext,\n          });\n\n          if (match === 'heuristic' && fragmentExecResult.missing) {\n            fragmentExecResult = {\n              ...fragmentExecResult,\n              missing: fragmentExecResult.missing.map(info => {\n                return { ...info, tolerable: true };\n              }),\n            };\n          }\n\n          objectsToMerge.push(handleMissing(fragmentExecResult));\n        }\n      }\n    });\n\n    // Perform a single merge at the end so that we can avoid making more\n    // defensive shallow copies than necessary.\n    finalResult.result = mergeDeepArray(objectsToMerge);\n\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(finalResult.result);\n    }\n\n    return finalResult;\n  }\n\n  private executeField(\n    object: StoreObject,\n    typename: string | void,\n    field: FieldNode,\n    execContext: ExecContext,\n  ): ExecResult {\n    const { variableValues: variables, contextValue } = execContext;\n    const fieldName = field.name.value;\n    const args = argumentsObjectFromField(field, variables);\n\n    const info: ExecInfo = {\n      resultKey: resultKeyNameFromField(field),\n      directives: getDirectiveInfoFromField(field, variables),\n    };\n\n    const readStoreResult = readStoreResolver(\n      object,\n      typename,\n      fieldName,\n      args,\n      contextValue,\n      info,\n    );\n\n    if (Array.isArray(readStoreResult.result)) {\n      return this.combineExecResults(\n        readStoreResult,\n        this.executeSubSelectedArray({\n          field,\n          array: readStoreResult.result,\n          execContext,\n        }),\n      );\n    }\n\n    // Handle all scalar types here\n    if (!field.selectionSet) {\n      assertSelectionSetForIdValue(field, readStoreResult.result);\n      if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n        maybeDeepFreeze(readStoreResult);\n      }\n      return readStoreResult;\n    }\n\n    // From here down, the field has a selection set, which means it's trying to\n    // query a GraphQLObjectType\n    if (readStoreResult.result == null) {\n      // Basically any field in a GraphQL response can be null, or missing\n      return readStoreResult;\n    }\n\n    // Returned value is an object, and the query has a sub-selection. Recurse.\n    return this.combineExecResults(\n      readStoreResult,\n      this.executeSelectionSet({\n        selectionSet: field.selectionSet,\n        rootValue: readStoreResult.result,\n        execContext,\n      }),\n    );\n  }\n\n  private combineExecResults<T>(\n    ...execResults: ExecResult<T>[]\n  ): ExecResult<T> {\n    let missing: ExecResultMissingField[] | undefined;\n    execResults.forEach(execResult => {\n      if (execResult.missing) {\n        missing = missing || [];\n        missing.push(...execResult.missing);\n      }\n    });\n    return {\n      result: execResults.pop()!.result,\n      missing,\n    };\n  }\n\n  private executeSubSelectedArray({\n    field,\n    array,\n    execContext,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: ExecResultMissingField[] | undefined;\n\n    function handleMissing<T>(childResult: ExecResult<T>): T {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push(...childResult.missing);\n      }\n\n      return childResult.result;\n    }\n\n    array = array.map(item => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (Array.isArray(item)) {\n        return handleMissing(this.executeSubSelectedArray({\n          field,\n          array: item,\n          execContext,\n        }));\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          rootValue: item,\n          execContext,\n        }));\n      }\n\n      assertSelectionSetForIdValue(field, item);\n\n      return item;\n    });\n\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(array);\n    }\n\n    return { result: array, missing };\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  field: FieldNode,\n  value: any,\n) {\n  if (!field.selectionSet && isIdValue(value)) {\n    throw new InvariantError(\n      `Missing selection set for object of type ${\n        value.typename\n      } returned for query field ${field.name.value}`\n    );\n  }\n}\n\nfunction defaultFragmentMatcher() {\n  return true;\n}\n\nexport function assertIdValue(idValue: IdValue) {\n  invariant(isIdValue(idValue), `\\\nEncountered a sub-selection on the query, but the store doesn't have \\\nan object reference. This should never happen during normal use unless you have custom code \\\nthat is directly manipulating the store; please file an issue.`);\n}\n\nfunction readStoreResolver(\n  object: StoreObject,\n  typename: string | void,\n  fieldName: string,\n  args: any,\n  context: ReadStoreContext,\n  { resultKey, directives }: ExecInfo,\n): ExecResult<StoreValue> {\n  let storeKeyName = fieldName;\n  if (args || directives) {\n    // We happen to know here that getStoreKeyName returns its first\n    // argument unmodified if there are no args or directives, so we can\n    // avoid calling the function at all in that case, as a small but\n    // important optimization to this frequently executed code.\n    storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n  }\n\n  let fieldValue: StoreValue | void = void 0;\n\n  if (object) {\n    fieldValue = object[storeKeyName];\n\n    if (\n      typeof fieldValue === 'undefined' &&\n      context.cacheRedirects &&\n      typeof typename === 'string'\n    ) {\n      // Look for the type in the custom resolver map\n      const type = context.cacheRedirects[typename];\n      if (type) {\n        // Look for the field in the custom resolver map\n        const resolver = type[fieldName];\n        if (resolver) {\n          fieldValue = resolver(object, args, {\n            getCacheKey(storeObj: StoreObject) {\n              const id = context.dataIdFromObject!(storeObj);\n              return id && toIdValue({\n                id,\n                typename: storeObj.__typename,\n              });\n            },\n          });\n        }\n      }\n    }\n  }\n\n  if (typeof fieldValue === 'undefined') {\n    return {\n      result: fieldValue,\n      missing: [{\n        object,\n        fieldName: storeKeyName,\n        tolerable: false,\n      }],\n    };\n  }\n\n  if (isJsonValue(fieldValue)) {\n    fieldValue = fieldValue.json;\n  }\n\n  return {\n    result: fieldValue,\n  };\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class ObjectCache implements NormalizedCache {\n  constructor(protected data: NormalizedCacheObject = Object.create(null)) {}\n\n  public toObject() {\n    return this.data;\n  }\n\n  public get(dataId: string) {\n    return this.data[dataId]!;\n  }\n\n  public set(dataId: string, value: StoreObject) {\n    this.data[dataId] = value;\n  }\n\n  public delete(dataId: string) {\n    this.data[dataId] = void 0;\n  }\n\n  public clear() {\n    this.data = Object.create(null);\n  }\n\n  public replace(newData: NormalizedCacheObject) {\n    this.data = newData || Object.create(null);\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new ObjectCache(seed);\n}\n","import {\n  SelectionSetNode,\n  FieldNode,\n  DocumentNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n} from 'graphql';\nimport { FragmentMatcher } from './readFromStore';\n\nimport {\n  assign,\n  createFragmentMap,\n  FragmentMap,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getOperationDefinition,\n  IdValue,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isProduction,\n  resultKeyNameFromField,\n  shouldInclude,\n  storeKeyNameFromField,\n  StoreValue,\n  toIdValue,\n  isEqual,\n} from 'apollo-utilities';\n\nimport { invariant } from 'ts-invariant';\n\nimport { ObjectCache } from './objectCache';\nimport { defaultNormalizedCacheFactory } from './depTrackingCache';\n\nimport {\n  IdGetter,\n  NormalizedCache,\n  ReadStoreContext,\n  StoreObject,\n} from './types';\n\nexport class WriteError extends Error {\n  public type = 'WriteError';\n}\n\nexport function enhanceErrorWithDocument(error: Error, document: DocumentNode) {\n  // XXX A bit hacky maybe ...\n  const enhancedError = new WriteError(\n    `Error writing result to store for query:\\n ${JSON.stringify(document)}`,\n  );\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\n\nexport type WriteContext = {\n  readonly store: NormalizedCache;\n  readonly processedData?: { [x: string]: FieldNode[] };\n  readonly variables?: any;\n  readonly dataIdFromObject?: IdGetter;\n  readonly fragmentMap?: FragmentMap;\n  readonly fragmentMatcherFunction?: FragmentMatcher;\n};\n\nexport class StoreWriter {\n  /**\n   * Writes the result of a query to the store.\n   *\n   * @param result The result object returned for the query document.\n   *\n   * @param query The query document whose result we are writing to the store.\n   *\n   * @param store The {@link NormalizedCache} used by Apollo for the `data` portion of the store.\n   *\n   * @param variables A map from the name of a variable to its value. These variables can be\n   * referenced by the query document.\n   *\n   * @param dataIdFromObject A function that returns an object identifier given a particular result\n   * object. See the store documentation for details and an example of this function.\n   *\n   * @param fragmentMatcherFunction A function to use for matching fragment conditions in GraphQL documents\n   */\n  public writeQueryToStore({\n    query,\n    result,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    query: DocumentNode;\n    result: Object;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    return this.writeResultToStore({\n      dataId: 'ROOT_QUERY',\n      result,\n      document: query,\n      store,\n      variables,\n      dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n  }\n\n  public writeResultToStore({\n    dataId,\n    result,\n    document,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    dataId: string;\n    result: any;\n    document: DocumentNode;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    // XXX TODO REFACTOR: this is a temporary workaround until query normalization is made to work with documents.\n    const operationDefinition = getOperationDefinition(document)!;\n\n    try {\n      return this.writeSelectionSetToStore({\n        result,\n        dataId,\n        selectionSet: operationDefinition.selectionSet,\n        context: {\n          store,\n          processedData: {},\n          variables: assign(\n            {},\n            getDefaultValues(operationDefinition),\n            variables,\n          ),\n          dataIdFromObject,\n          fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n          fragmentMatcherFunction,\n        },\n      });\n    } catch (e) {\n      throw enhanceErrorWithDocument(e, document);\n    }\n  }\n\n  public writeSelectionSetToStore({\n    result,\n    dataId,\n    selectionSet,\n    context,\n  }: {\n    dataId: string;\n    result: any;\n    selectionSet: SelectionSetNode;\n    context: WriteContext;\n  }): NormalizedCache {\n    const { variables, store, fragmentMap } = context;\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        return;\n      }\n\n      if (isField(selection)) {\n        const resultFieldKey: string = resultKeyNameFromField(selection);\n        const value: any = result[resultFieldKey];\n\n        if (typeof value !== 'undefined') {\n          this.writeFieldToStore({\n            dataId,\n            value,\n            field: selection,\n            context,\n          });\n        } else {\n          let isDefered = false;\n          let isClient = false;\n          if (selection.directives && selection.directives.length) {\n            // If this is a defered field we don't need to throw / warn.\n            isDefered = selection.directives.some(\n              directive => directive.name && directive.name.value === 'defer',\n            );\n\n            // When using the @client directive, it might be desirable in\n            // some cases to want to write a selection set to the store,\n            // without having all of the selection set values available.\n            // This is because the @client field values might have already\n            // been written to the cache separately (e.g. via Apollo\n            // Cache's `writeData` capabilities). Because of this, we'll\n            // skip the missing field warning for fields with @client\n            // directives.\n            isClient = selection.directives.some(\n              directive => directive.name && directive.name.value === 'client',\n            );\n          }\n\n          if (!isDefered && !isClient && context.fragmentMatcherFunction) {\n            // XXX We'd like to throw an error, but for backwards compatibility's sake\n            // we just print a warning for the time being.\n            //throw new WriteError(`Missing field ${resultFieldKey} in ${JSON.stringify(result, null, 2).substring(0, 100)}`);\n            invariant.warn(\n              `Missing field ${resultFieldKey} in ${JSON.stringify(\n                result,\n                null,\n                2,\n              ).substring(0, 100)}`,\n            );\n          }\n        }\n      } else {\n        // This is not a field, so it must be a fragment, either inline or named\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // Named fragment\n          fragment = (fragmentMap || {})[selection.name.value];\n          invariant(fragment, `No fragment named ${selection.name.value}.`);\n        }\n\n        let matches = true;\n        if (context.fragmentMatcherFunction && fragment.typeCondition) {\n          // TODO we need to rewrite the fragment matchers for this to work properly and efficiently\n          // Right now we have to pretend that we're passing in an idValue and that there's a store\n          // on the context.\n          const id = dataId || 'self';\n          const idValue = toIdValue({ id, typename: undefined });\n          const fakeContext: ReadStoreContext = {\n            // NOTE: fakeContext always uses ObjectCache\n            // since this is only to ensure the return value of 'matches'\n            store: new ObjectCache({ [id]: result }),\n            cacheRedirects: {},\n          };\n          const match = context.fragmentMatcherFunction(\n            idValue,\n            fragment.typeCondition.name.value,\n            fakeContext,\n          );\n          if (!isProduction() && match === 'heuristic') {\n            invariant.error('WARNING: heuristic fragment matching going on!');\n          }\n          matches = !!match;\n        }\n\n        if (matches) {\n          this.writeSelectionSetToStore({\n            result,\n            selectionSet: fragment.selectionSet,\n            dataId,\n            context,\n          });\n        }\n      }\n    });\n\n    return store;\n  }\n\n  private writeFieldToStore({\n    field,\n    value,\n    dataId,\n    context,\n  }: {\n    field: FieldNode;\n    value: any;\n    dataId: string;\n    context: WriteContext;\n  }) {\n    const { variables, dataIdFromObject, store } = context;\n\n    let storeValue: StoreValue;\n    let storeObject: StoreObject;\n\n    const storeFieldName: string = storeKeyNameFromField(field, variables);\n\n    // If this is a scalar value...\n    if (!field.selectionSet || value === null) {\n      storeValue =\n        value != null && typeof value === 'object'\n          ? // If the scalar value is a JSON blob, we have to \"escape\" it so it can’t pretend to be\n            // an id.\n            { type: 'json', json: value }\n          : // Otherwise, just store the scalar directly in the store.\n            value;\n    } else if (Array.isArray(value)) {\n      const generatedId = `${dataId}.${storeFieldName}`;\n\n      storeValue = this.processArrayValue(\n        value,\n        generatedId,\n        field.selectionSet,\n        context,\n      );\n    } else {\n      // It's an object\n      let valueDataId = `${dataId}.${storeFieldName}`;\n      let generated = true;\n\n      // We only prepend the '$' if the valueDataId isn't already a generated\n      // id.\n      if (!isGeneratedId(valueDataId)) {\n        valueDataId = '$' + valueDataId;\n      }\n\n      if (dataIdFromObject) {\n        const semanticId = dataIdFromObject(value);\n\n        // We throw an error if the first character of the id is '$. This is\n        // because we use that character to designate an Apollo-generated id\n        // and we use the distinction between user-desiginated and application-provided\n        // ids when managing overwrites.\n        invariant(\n          !semanticId || !isGeneratedId(semanticId),\n          'IDs returned by dataIdFromObject cannot begin with the \"$\" character.',\n        );\n\n        if (\n          semanticId ||\n          (typeof semanticId === 'number' && semanticId === 0)\n        ) {\n          valueDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(valueDataId, field, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: valueDataId,\n          result: value,\n          selectionSet: field.selectionSet,\n          context,\n        });\n      }\n\n      // We take the id and escape it (i.e. wrap it with an enclosing object).\n      // This allows us to distinguish IDs from normal scalars.\n      const typename = value.__typename;\n      storeValue = toIdValue({ id: valueDataId, typename }, generated);\n\n      // check if there was a generated id at the location where we're\n      // about to place this new id. If there was, we have to merge the\n      // data from that id with the data we're about to write in the store.\n      storeObject = store.get(dataId);\n      const escapedId =\n        storeObject && (storeObject[storeFieldName] as IdValue | undefined);\n      if (escapedId !== storeValue && isIdValue(escapedId)) {\n        const hadTypename = escapedId.typename !== undefined;\n        const hasTypename = typename !== undefined;\n        const typenameChanged =\n          hadTypename && hasTypename && escapedId.typename !== typename;\n\n        // If there is already a real id in the store and the current id we\n        // are dealing with is generated, we throw an error.\n        // One exception we allow is when the typename has changed, which occurs\n        // when schema defines a union, both with and without an ID in the same place.\n        // checks if we \"lost\" the read id\n        invariant(\n          !generated || escapedId.generated || typenameChanged,\n          `Store error: the application attempted to write an object with no provided id but the store already contains an id of ${\n            escapedId.id\n          } for this object. The selectionSet that was trying to be written is:\\n${\n            JSON.stringify(field)\n          }`,\n        );\n\n        // checks if we \"lost\" the typename\n        invariant(\n          !hadTypename || hasTypename,\n          `Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of ${\n            escapedId.typename\n          } for the object of id ${escapedId.id}. The selectionSet that was trying to be written is:\\n${\n            JSON.stringify(field)\n          }`,\n        );\n\n        if (escapedId.generated) {\n          // We should only merge if it's an object of the same type,\n          // otherwise we should delete the generated object\n          if (typenameChanged) {\n            // Only delete the generated object when the old object was\n            // inlined, and the new object is not. This is indicated by\n            // the old id being generated, and the new id being real.\n            if (!generated) {\n              store.delete(escapedId.id);\n            }\n          } else {\n            mergeWithGenerated(escapedId.id, (storeValue as IdValue).id, store);\n          }\n        }\n      }\n    }\n\n    storeObject = store.get(dataId);\n    if (!storeObject || !isEqual(storeValue, storeObject[storeFieldName])) {\n      store.set(dataId, {\n        ...storeObject,\n        [storeFieldName]: storeValue,\n      });\n    }\n  }\n\n  private processArrayValue(\n    value: any[],\n    generatedId: string,\n    selectionSet: SelectionSetNode,\n    context: WriteContext,\n  ): any[] {\n    return value.map((item: any, index: any) => {\n      if (item === null) {\n        return null;\n      }\n\n      let itemDataId = `${generatedId}.${index}`;\n\n      if (Array.isArray(item)) {\n        return this.processArrayValue(item, itemDataId, selectionSet, context);\n      }\n\n      let generated = true;\n\n      if (context.dataIdFromObject) {\n        const semanticId = context.dataIdFromObject(item);\n\n        if (semanticId) {\n          itemDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: itemDataId,\n          result: item,\n          selectionSet,\n          context,\n        });\n      }\n\n      return toIdValue(\n        { id: itemDataId, typename: item.__typename },\n        generated,\n      );\n    });\n  }\n}\n\n// Checks if the id given is an id that was generated by Apollo\n// rather than by dataIdFromObject.\nfunction isGeneratedId(id: string): boolean {\n  return id[0] === '$';\n}\n\nfunction mergeWithGenerated(\n  generatedKey: string,\n  realKey: string,\n  cache: NormalizedCache,\n): boolean {\n  if (generatedKey === realKey) {\n    return false;\n  }\n\n  const generated = cache.get(generatedKey);\n  const real = cache.get(realKey);\n  let madeChanges = false;\n\n  Object.keys(generated).forEach(key => {\n    const value = generated[key];\n    const realValue = real[key];\n\n    if (\n      isIdValue(value) &&\n      isGeneratedId(value.id) &&\n      isIdValue(realValue) &&\n      !isEqual(value, realValue) &&\n      mergeWithGenerated(value.id, realValue.id, cache)\n    ) {\n      madeChanges = true;\n    }\n  });\n\n  cache.delete(generatedKey);\n  const newRealValue = { ...generated, ...real };\n\n  if (isEqual(newRealValue, real)) {\n    return madeChanges;\n  }\n\n  cache.set(realKey, newRealValue);\n  return true;\n}\n\nfunction isDataProcessed(\n  dataId: string,\n  field: FieldNode | SelectionSetNode,\n  processedData?: { [x: string]: (FieldNode | SelectionSetNode)[] },\n): boolean {\n  if (!processedData) {\n    return false;\n  }\n\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n\n  return false;\n}\n","// Make builtins like Map and Set safe to use with non-extensible objects.\nimport './fixPolyfills';\n\nimport { DocumentNode } from 'graphql';\n\nimport { Cache, ApolloCache, Transaction } from 'apollo-cache';\n\nimport { addTypenameToDocument, canUseWeakMap } from 'apollo-utilities';\n\nimport { wrap } from 'optimism';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { HeuristicFragmentMatcher } from './fragmentMatcher';\nimport {\n  ApolloReducerConfig,\n  NormalizedCache,\n  NormalizedCacheObject,\n} from './types';\n\nimport { StoreReader } from './readFromStore';\nimport { StoreWriter } from './writeToStore';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { KeyTrie } from 'optimism';\nimport { ObjectCache } from './objectCache';\n\nexport interface InMemoryCacheConfig extends ApolloReducerConfig {\n  resultCaching?: boolean;\n  freezeResults?: boolean;\n}\n\nconst defaultConfig: InMemoryCacheConfig = {\n  fragmentMatcher: new HeuristicFragmentMatcher(),\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  freezeResults: false,\n};\n\nexport function defaultDataIdFromObject(result: any): string | null {\n  if (result.__typename) {\n    if (result.id !== undefined) {\n      return `${result.__typename}:${result.id}`;\n    }\n    if (result._id !== undefined) {\n      return `${result.__typename}:${result._id}`;\n    }\n  }\n  return null;\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class OptimisticCacheLayer extends ObjectCache {\n  constructor(\n    public readonly optimisticId: string,\n    // OptimisticCacheLayer objects always wrap some other parent cache, so\n    // this.parent should never be null.\n    public readonly parent: NormalizedCache,\n    public readonly transaction: Transaction<NormalizedCacheObject>,\n  ) {\n    super(Object.create(null));\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  // All the other accessor methods of ObjectCache work without knowing about\n  // this.parent, but the get method needs to be overridden to implement the\n  // fallback this.parent.get(dataId) behavior.\n  public get(dataId: string) {\n    return hasOwn.call(this.data, dataId)\n      ? this.data[dataId]\n      : this.parent.get(dataId);\n  }\n}\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data: NormalizedCache;\n  private optimisticData: NormalizedCache;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n  private typenameDocumentCache = new Map<DocumentNode, DocumentNode>();\n  private storeReader: StoreReader;\n  private storeWriter: StoreWriter;\n  private cacheKeyRoot = new KeyTrie<object>(canUseWeakMap);\n\n  // Set this while in a transaction to prevent broadcasts...\n  // don't forget to turn it back on!\n  private silenceBroadcast: boolean = false;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n\n    // backwards compat\n    if ((this.config as any).customResolvers) {\n      invariant.warn(\n        'customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).customResolvers;\n    }\n\n    if ((this.config as any).cacheResolvers) {\n      invariant.warn(\n        'cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).cacheResolvers;\n    }\n\n    this.addTypename = !!this.config.addTypename;\n\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    this.data = this.config.resultCaching\n      ? new DepTrackingCache()\n      : new ObjectCache();\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of OptimisticCacheLayer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = this.data;\n\n    this.storeWriter = new StoreWriter();\n    this.storeReader = new StoreReader({\n      cacheKeyRoot: this.cacheKeyRoot,\n      freezeResults: config.freezeResults,\n    });\n\n    const cache = this;\n    const { maybeBroadcastWatch } = cache;\n    this.maybeBroadcastWatch = wrap((c: Cache.WatchOptions) => {\n      return maybeBroadcastWatch.call(this, c);\n    }, {\n      makeCacheKey(c: Cache.WatchOptions) {\n        if (c.optimistic) {\n          // If we're reading optimistic data, it doesn't matter if this.data\n          // is a DepTrackingCache, since it will be ignored.\n          return;\n        }\n\n        if (c.previousResult) {\n          // If a previousResult was provided, assume the caller would prefer\n          // to compare the previous data to the new data to determine whether\n          // to broadcast, so we should disable caching by returning here, to\n          // give maybeBroadcastWatch a chance to do that comparison.\n          return;\n        }\n\n        if (cache.data instanceof DepTrackingCache) {\n          // Return a cache key (thus enabling caching) only if we're currently\n          // using a data store that can track cache dependencies.\n          return cache.cacheKeyRoot.lookup(\n            c.query,\n            JSON.stringify(c.variables),\n          );\n        }\n      }\n    });\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).toObject();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    if (typeof options.rootId === 'string' &&\n        typeof this.data.get(options.rootId) === 'undefined') {\n      return null;\n    }\n\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    return this.storeReader.readQueryFromStore({\n      store: options.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(options.query),\n      variables: options.variables,\n      rootId: options.rootId,\n      fragmentMatcherFunction,\n      previousResult: options.previousResult,\n      config: this.config,\n    }) || null;\n  }\n\n  public write(write: Cache.WriteOptions): void {\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    this.storeWriter.writeResultToStore({\n      dataId: write.dataId,\n      result: write.result,\n      variables: write.variables,\n      document: this.transformDocument(write.query),\n      store: this.data,\n      dataIdFromObject: this.config.dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n\n    this.broadcastWatches();\n  }\n\n  public diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T> {\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    return this.storeReader.diffQueryAgainstStore({\n      store: query.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      returnPartialData: query.returnPartialData,\n      previousResult: query.previousResult,\n      fragmentMatcherFunction,\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    this.watches.add(watch);\n\n    return () => {\n      this.watches.delete(watch);\n    };\n  }\n\n  public evict(query: Cache.EvictOptions): Cache.EvictionResult {\n    throw new InvariantError(`eviction is not implemented on InMemory Cache`);\n  }\n\n  public reset(): Promise<void> {\n    this.data.clear();\n    this.broadcastWatches();\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const toReapply: OptimisticCacheLayer[] = [];\n    let removedCount = 0;\n    let layer = this.optimisticData;\n\n    while (layer instanceof OptimisticCacheLayer) {\n      if (layer.optimisticId === idToRemove) {\n        ++removedCount;\n      } else {\n        toReapply.push(layer);\n      }\n      layer = layer.parent;\n    }\n\n    if (removedCount > 0) {\n      // Reset this.optimisticData to the first non-OptimisticCacheLayer object,\n      // which is almost certainly this.data.\n      this.optimisticData = layer;\n\n      // Reapply the layers whose optimistic IDs do not match the removed ID.\n      while (toReapply.length > 0) {\n        const layer = toReapply.pop()!;\n        this.performTransaction(layer.transaction, layer.optimisticId);\n      }\n\n      this.broadcastWatches();\n    }\n  }\n\n  public performTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    // This parameter is not part of the performTransaction signature inherited\n    // from the ApolloCache abstract class, but it's useful because it saves us\n    // from duplicating this implementation in recordOptimisticTransaction.\n    optimisticId?: string,\n  ) {\n    const { data, silenceBroadcast } = this;\n    this.silenceBroadcast = true;\n\n    if (typeof optimisticId === 'string') {\n      // Add a new optimistic layer and temporarily make this.data refer to\n      // that layer for the duration of the transaction.\n      this.data = this.optimisticData = new OptimisticCacheLayer(\n        // Note that there can be multiple layers with the same optimisticId.\n        // When removeOptimistic(id) is called for that id, all matching layers\n        // will be removed, and the remaining layers will be reapplied.\n        optimisticId,\n        this.optimisticData,\n        transaction,\n      );\n    }\n\n    try {\n      transaction(this);\n    } finally {\n      this.silenceBroadcast = silenceBroadcast;\n      this.data = data;\n    }\n\n    // This broadcast does nothing if this.silenceBroadcast is true.\n    this.broadcastWatches();\n  }\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    id: string,\n  ) {\n    return this.performTransaction(transaction, id);\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        result = addTypenameToDocument(document);\n        this.typenameDocumentCache.set(document, result);\n        // If someone calls transformDocument and then mistakenly passes the\n        // result back into an API that also calls transformDocument, make sure\n        // we don't keep creating new query documents.\n        this.typenameDocumentCache.set(result, result);\n      }\n      return result;\n    }\n    return document;\n  }\n\n  protected broadcastWatches() {\n    if (!this.silenceBroadcast) {\n      this.watches.forEach(c => this.maybeBroadcastWatch(c));\n    }\n  }\n\n  // This method is wrapped in the constructor so that it will be called only\n  // if the data that would be broadcast has changed.\n  private maybeBroadcastWatch(c: Cache.WatchOptions) {\n    c.callback(\n      this.diff({\n        query: c.query,\n        variables: c.variables,\n        previousResult: c.previousResult && c.previousResult(),\n        optimistic: c.optimistic,\n      }),\n    );\n  }\n}\n"]}